<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Control - Tu Ti√™n Fight</title>
  <style>
    :root{ --ui:#00ffff; --panel: rgba(0,0,0,.78); }
    body{ margin:0; background:#05050a; color:#fff; font-family:system-ui,Segoe UI,Arial; overflow:hidden; }
    .input_video{ position: fixed; width:1px; height:1px; opacity:0; pointer-events:none; left:-10px; top:-10px; }
    #loading{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background: rgba(0,0,0,.85);
      border: 1px solid rgba(0,255,255,.55);
      border-radius: 12px;
      padding: 18px 20px;
      text-align:center;
      color: var(--ui);
      text-shadow: 0 0 12px rgba(0,255,255,.35);
      backdrop-filter: blur(6px);
      z-index: 5;
      max-width: 560px;
      line-height: 1.35;
    }
    #startBtn{
      position:absolute; top: calc(50% + 76px); left:50%; transform:translateX(-50%);
      z-index:6;
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(0,0,0,.82);
      color: var(--ui);
      border: 1px solid rgba(0,255,255,.6);
      cursor:pointer;
      user-select:none;
      font-weight: 800;
      letter-spacing: .5px;
      box-shadow: 0 0 18px rgba(0,255,255,.12);
    }
    #startBtn:active{ transform:translateX(-50%) scale(.98); }
    #skill-name{
      position:absolute; left:0; right:0; top: 22px;
      text-align:center;
      font-size: 32px; font-weight: 900;
      letter-spacing: 5px;
      opacity:0; transform: translateY(-10px) scale(.98);
      transition: opacity .22s ease, transform .22s ease, filter .22s ease;
      filter: drop-shadow(0 0 18px rgba(255,0,222,.55));
      user-select:none;
      z-index:2;
    }
    #skill-name.show{
      opacity:1; transform: translateY(0) scale(1);
      filter: drop-shadow(0 0 28px rgba(0,255,255,.25));
    }
    #controls{
      position:absolute; top: 16px; right: 16px;
      background: var(--panel);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
      display:flex; flex-direction:column; gap:8px;
      min-width: 260px;
      z-index:2;
    }
    #net{
      font-size:12px; opacity:.9;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      line-height:1.35;
    }
    label{ font-size: 12px; color: rgba(255,255,255,.75); display:flex; gap:10px; align-items:center; justify-content:space-between;}
    select,input[type="text"]{
      width:100%;
      background: rgba(255,255,255,.06);
      color:#fff;
      border: 1px solid rgba(255,255,255,.12);
      padding: 8px 10px;
      border-radius: 10px;
      outline:none;
    }
    .btn{
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid rgba(0,255,255,.35);
      background: rgba(0,0,0,.55);
      color: var(--ui);
      cursor:pointer;
      font-weight:900;
      letter-spacing:.5px;
    }
    .btn:active{ transform: scale(.99); }
    #guide{
      position:absolute; left: 16px; bottom: 16px;
      width: 410px;
      background: linear-gradient(90deg, rgba(0,0,0,.86), rgba(0,0,0,.18));
      border-left: 4px solid rgba(0,255,255,.8);
      padding: 14px 16px;
      backdrop-filter: blur(6px);
      z-index:2;
    }
    #guide-title{
      font-size: 16px; font-weight:900; letter-spacing:2px;
      margin-bottom:10px;
      border-bottom: 1px solid rgba(255,255,255,.16);
      padding-bottom: 6px;
    }
    .move{ margin-bottom: 8px; font-size: 13px; display:flex; gap:10px; }
    .icon{ width: 26px; font-size: 18px; line-height:1.1; }
    .name{ font-weight: 900; color: var(--ui); margin-right: 6px; }
    .desc{ font-size: 12px; color: rgba(255,255,255,.6); font-style: italic; }
    .hint{ font-size:11px; opacity:.7; margin-top:8px; }
  </style>
</head>
<body>
  <div id="skill-name">‚Äî</div>

  <div id="loading">Nh·∫•n ‚ÄúB·∫Øt ƒë·∫ßu Camera‚Äù ƒë·ªÉ k√≠ch ho·∫°t nh·∫≠n di·ªán tay.</div>
  <div id="startBtn">B·∫Øt ƒë·∫ßu Camera</div>

  <div id="controls">
    <div id="net">üîå Net: <span id="netText">Ch∆∞a k·∫øt n·ªëi</span></div>
    <label>Room <input id="roomInput" type="text" value="demo" /></label>
    <label>
      Player
      <select id="playerSelect">
        <option value="1">Player 1</option>
        <option value="2">Player 2</option>
      </select>
    </label>
    <button id="joinBtn" class="btn">K·∫øt n·ªëi Room</button>
    <div class="hint">Test nhanh: <b>Q/W/E/R/T/Y/U/I</b></div>
  </div>

  <div id="guide">
    <div id="guide-title">B√ç K√çP (CONTROL)</div>

    <div class="move"><span class="icon">‚úã</span><div><span class="name">Li√™n Hoa:</span><span class="desc">X√≤e tay</span></div></div>
    <div class="move"><span class="icon">üëç</span><div><span class="name">H·ªô Th√¢n C·∫ßu:</span><span class="desc">Gi∆° ng√≥n c√°i</span></div></div>

    <!-- UPDATED: ULT combo -->
    <div class="move"><span class="icon">‚ö°</span><div><span class="name">ULT:</span><span class="desc">1 tay ‚úåÔ∏è + 1 tay ü§ò (ATTACK + WALL c√πng l√∫c)</span></div></div>

    <div class="move"><span class="icon">üôå</span><div><span class="name">GIANT:</span><span class="desc">2 tay m·ªü gi∆° cao, gi·ªØ 3 gi√¢y</span></div></div>
    <div class="move"><span class="icon">‚úåÔ∏è</span><div><span class="name">Attack:</span><span class="desc">2 ng√≥n</span></div></div>
    <div class="move"><span class="icon">ü§ò</span><div><span class="name">Wall:</span><span class="desc">Tr·ªè + √öt</span></div></div>
    <div class="move"><span class="icon">üëå</span><div><span class="name">Spin:</span><span class="desc">Ch·∫°m c√°i + tr·ªè</span></div></div>
    <div class="move"><span class="icon">‚òùÔ∏è</span><div><span class="name">AIM:</span><span class="desc">1 ng√≥n tr·ªè</span></div></div>
    <div class="move"><span class="icon">üñêÔ∏è</span><div><span class="name">Fan:</span><span class="desc">4 ng√≥n (kh√©p ng√≥n c√°i)</span></div></div>

    <div class="hint">PC (Display) g√°nh combat/VFX, ƒëi·ªán tho·∫°i ch·ªâ g·ª≠i input.</div>
  </div>

  <video class="input_video" playsinline muted></video>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <script src="/socket.io/socket.io.js"></script>

  <script>
    const loadingEl = document.getElementById('loading');
    const startBtn  = document.getElementById('startBtn');

    const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    const isSecure = window.isSecureContext || isLocalhost;

    if (!isSecure){
      loadingEl.style.display = 'block';
      loadingEl.innerHTML =
        'Kh√¥ng th·ªÉ m·ªü camera v√¨ trang ch∆∞a an to√†n.<br/>' +
        'H√£y ch·∫°y b·∫±ng <b>https</b> ho·∫∑c <b>http://localhost</b>.';
      startBtn.style.display = 'none';
    }

    // Socket
    const netText = document.getElementById('netText');
    const roomInput = document.getElementById('roomInput');
    const playerSelect = document.getElementById('playerSelect');
    const joinBtn = document.getElementById('joinBtn');

    const qs = new URLSearchParams(location.search);
    roomInput.value = (qs.get('room') || 'demo').trim() || 'demo';
    playerSelect.value = (qs.get('player') === '2') ? '2' : '1';

    let socket = null;
    let ROOM = roomInput.value.trim() || 'demo';
    let PLAYER = Number(playerSelect.value) === 2 ? 2 : 1;
    let joinedOk = false;

    function setNet(s){ netText.textContent = s; }

    function connectAndJoin(){
      ROOM = roomInput.value.trim() || 'demo';
      PLAYER = Number(playerSelect.value) === 2 ? 2 : 1;

      if (!socket){
        socket = io();
        socket.on('connect', ()=>{
          joinedOk = false;
          setNet(`‚úÖ Connected | room=${ROOM} | P${PLAYER}`);
          socket.emit('join', { room: ROOM, role:'player', player: PLAYER });
        });
        socket.on('joined', (info)=>{
          joinedOk = true;
          setNet(`üü¢ Joined room=${info.room} | Player ${info.player}`);
        });
        socket.on('roster', (r)=>{
          if (!joinedOk) return;
          setNet(`üü¢ room=${ROOM} | P1:${r.p1?'ON':'OFF'} P2:${r.p2?'ON':'OFF'} | Display:${r.displayCount}`);
        });
        socket.on('join_error', (e)=>{
          joinedOk = false;
          setNet(`‚ùå join_error: ${e?.message || 'unknown'}`);
        });
        socket.on('disconnect', ()=>{
          joinedOk = false;
          setNet('‚ö†Ô∏è Disconnected');
        });
      } else {
        joinedOk = false;
        socket.emit('join', { room: ROOM, role:'player', player: PLAYER });
        setNet(`‚Üª Re-join‚Ä¶ room=${ROOM} P${PLAYER}`);
      }
    }

    joinBtn.addEventListener('click', connectAndJoin);
    connectAndJoin();

    // ======= gesture names =======
    const GESTURE = {
      IDLE:   'IDLE',
      LOTUS:  'LOTUS',
      SPHERE: 'SPHERE',
      ATTACK: 'ATTACK',
      WALL:   'WALL',
      SPIN:   'SPIN',
      GIANT:  'GIANT',
      POINT:  'POINT',
      SHAKA:  'SHAKA',
      FAN:    'FAN'
    };

    // ======= mapping skillName =======
    const GESTURE_TO_SKILLNAME = {
      LOTUS:  "Li√™n Hoa Tr·∫≠n",
      SPHERE: "H·ªô Th√¢n Ki·∫øm C·∫ßu",
      ATTACK: "Ph√° Thi√™n K√≠ch",
      WALL:   "Thi√™n La ƒê·ªãa V√µng",
      SPIN:   "Spin",
      GIANT:  "Giant",
      POINT:  "AIM",
      SHAKA:  "ULT / H·ªìi Ki·∫øm",
      FAN:    "Fan",
      IDLE:   "‚Äî"
    };

    const skillNameEl = document.getElementById('skill-name');
    function showSkillName(name){
      skillNameEl.textContent = name;
      skillNameEl.classList.add('show');
      clearTimeout(window.__skillT);
      window.__skillT = setTimeout(()=> skillNameEl.classList.remove('show'), 900);
    }

    const video = document.querySelector('.input_video');
    video.setAttribute('playsinline','');
    video.muted = true;
    video.autoplay = true;

    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.65,
      minTrackingConfidence: 0.65
    });

    let gotFirstResults = false;

    // ======= gi·ªØ raw theo L/R ƒë·ªÉ aim ·ªïn ƒë·ªãnh =======
    let handDetected = false;
    let handRawL = null;
    let handRawR = null;
    let primaryHandRaw = null;

    function dist2(a,b){
      const dx = a.x-b.x, dy = a.y-b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function handSize(lm){
      return Math.max(0.12, dist2(lm[0], lm[9]));
    }
    function isExtended(lm, tipIdx, mcpIdx, extMul){
      const wrist = lm[0];
      const tip = lm[tipIdx];
      const mcp = lm[mcpIdx];
      return dist2(tip, wrist) > dist2(mcp, wrist) * extMul;
    }

    function isOpenPalm(lm){
      const extMul = 1.24;
      const thumbOut  = isExtended(lm, 4, 2, extMul);
      const indexOut  = isExtended(lm, 8, 5, extMul);
      const middleOut = isExtended(lm,12, 9, extMul);
      const ringOut   = isExtended(lm,16,13, extMul);
      const pinkyOut  = isExtended(lm,20,17, extMul);
      const extCount = [thumbOut,indexOut,middleOut,ringOut,pinkyOut].filter(Boolean).length;
      return extCount >= 4;
    }

    // ======= fist nh·∫π ƒë·ªÉ h·ªó tr·ª£ 2-hand FIST+POINT => SHAKA =======
    function isFist(lm){
      const wrist = lm[0];
      const middleMCP = lm[9];
      const hs = Math.max(0.12, dist2(wrist, middleMCP));
      const fistTh = hs * 0.92;

      const tips = [lm[8], lm[12], lm[16], lm[20]];
      const avg = (dist2(tips[0], wrist) + dist2(tips[1], wrist) + dist2(tips[2], wrist) + dist2(tips[3], wrist)) / 4;

      const extMul = 1.18;
      const indexOut  = isExtended(lm, 8, 5, extMul);
      const middleOut = isExtended(lm,12, 9, extMul);
      const ringOut   = isExtended(lm,16,13, extMul);
      const pinkyOut  = isExtended(lm,20,17, extMul);
      const extCount = [indexOut,middleOut,ringOut,pinkyOut].filter(Boolean).length;

      return avg < fistTh && extCount <= 1;
    }

    // ======= 2-hand gesture tr·∫£ v·ªÅ SHAKA ho·∫∑c null =======
    let baseOrderSign = 0;
    let crossHold = 0;
    const CROSS_NEED = 8;
    const CROSS_GAP = 0.06;

    function palmCenter(lm){ return lm ? lm[9] : null; }

    function detectTwoHandsGesture(lmList, handed){
      if (!lmList || lmList.length < 2) { baseOrderSign = 0; crossHold = 0; return null; }

      const a = lmList[0];
      const b = lmList[1];

      // A) 2 open palms near => SHAKA
      if (isOpenPalm(a) && isOpenPalm(b)){
        const ca = a[9];
        const cb = b[9];
        const d = dist2(ca, cb);
        const s = (handSize(a) + handSize(b)) * 0.5;
        const NEAR = 0.78;
        if (d < s * NEAR) return GESTURE.SHAKA;
      }

      // B) CROSS X => SHAKA
      let L = null, R = null;
      if (handed && handed.length >= 2){
        for(let i=0;i<2;i++){
          const label = handed[i]?.label;
          if(label === 'Left') L = lmList[i];
          else if(label === 'Right') R = lmList[i];
        }
      }
      if(!L || !R){
        const w0 = lmList[0][0].x, w1 = lmList[1][0].x;
        if (w0 < w1){ R = lmList[0]; L = lmList[1]; }
        else { R = lmList[1]; L = lmList[0]; }
      }

      const cL = palmCenter(L);
      const cR = palmCenter(R);
      if(cL && cR){
        const dx = (cR.x - cL.x);
        const sign = Math.sign(dx) || 0;
        if(baseOrderSign === 0) baseOrderSign = sign || 1;

        const crossed = (sign !== 0 && sign !== baseOrderSign && Math.abs(dx) > CROSS_GAP);
        crossHold = crossed ? Math.min(CROSS_NEED+2, crossHold+1) : Math.max(0, crossHold-1);

        if (crossHold >= CROSS_NEED) return GESTURE.SHAKA;

        if(!crossed && Math.abs(dx) > 0.04) baseOrderSign = sign || baseOrderSign;
      }

      // C) FIST + POINT => SHAKA
      const g0 = detectGestureSingle(a);
      const g1 = detectGestureSingle(b);
      const aF = isFist(a), bF = isFist(b);

      const fistPoint =
        (aF && g1 === GESTURE.POINT) ||
        (bF && g0 === GESTURE.POINT);

      if (fistPoint) return GESTURE.SHAKA;

      return null;
    }

    // ======= GIANT = 2 tay m·ªü gi∆° cao + gi·ªØ 3s =======
    const GIANT_RAISE_Y = 0.48;
    const GIANT_HOLD_MS = 3000;

    function isTwoHandsRaised(lmList){
      if (!lmList || lmList.length < 2) return false;
      const a = lmList[0];
      const b = lmList[1];
      if (!isOpenPalm(a) || !isOpenPalm(b)) return false;
      const ca = a[9];
      const cb = b[9];
      return (ca.y < GIANT_RAISE_Y && cb.y < GIANT_RAISE_Y);
    }

    let giantCharging = false;
    let giantChargeStartAt = 0;
    let giantFired = false;

    function sendAuxGesture(gesture){
      if (!socket || !socket.connected || !joinedOk) return;
      socket.emit('input', { gesture, skillName: gesture, dir: computeAimDir() });
    }

    function handleGiantHold(raised){
      const now = Date.now();

      if (raised){
        if (!giantCharging){
          giantCharging = true;
          giantFired = false;
          giantChargeStartAt = now;
          sendAuxGesture('GIANT_CHARGE');
          showSkillName('Giant (Charge)');
        }

        if (!giantFired && (now - giantChargeStartAt) >= GIANT_HOLD_MS){
          giantFired = true;
          giantCharging = false;
          sendAuxGesture('GIANT_CANCEL');
          commitGesture(GESTURE.GIANT);
        }
        return true;
      }

      if (giantCharging){
        giantCharging = false;
        giantFired = false;
        giantChargeStartAt = 0;
        sendAuxGesture('GIANT_CANCEL');
      }
      return false;
    }

    // ======= SINGLE gesture =======
    function detectGestureSingle(lm){
      const wrist = lm[0];
      const thumbTip = lm[4];
      const indexTip = lm[8];
      const middleTip = lm[12];
      const ringTip = lm[16];
      const pinkyTip = lm[20];

      const thumbMCP = lm[2];
      const indexMCP = lm[5];
      const middleMCP = lm[9];
      const ringMCP = lm[13];
      const pinkyMCP = lm[17];

      const hs = Math.max(0.12, dist2(wrist, middleMCP));
      const pinchTh = hs * 0.17;
      const extMul  = 1.26;

      const thumbOut  = dist2(thumbTip, wrist)  > dist2(thumbMCP, wrist)  * extMul;
      const indexOut  = dist2(indexTip, wrist)  > dist2(indexMCP, wrist)  * extMul;
      const middleOut = dist2(middleTip, wrist) > dist2(middleMCP, wrist) * extMul;
      const ringOut   = dist2(ringTip, wrist)   > dist2(ringMCP, wrist)   * extMul;
      const pinkyOut  = dist2(pinkyTip, wrist)  > dist2(pinkyMCP, wrist)  * extMul;

      const pinchThumbIndex = dist2(thumbTip, indexTip) < pinchTh;

      // SPIN: ch·∫°m c√°i + tr·ªè
      if (pinchThumbIndex && (middleOut || ringOut || pinkyOut || !indexOut)) return GESTURE.SPIN;

      // WALL: tr·ªè + √∫t
      if (indexOut && pinkyOut && !middleOut && !ringOut) return GESTURE.WALL;

      // ATTACK: 2 ng√≥n
      if (indexOut && middleOut && !ringOut && !pinkyOut) return GESTURE.ATTACK;

      // AIM: 1 ng√≥n tr·ªè
      if (indexOut && !middleOut && !ringOut && !pinkyOut && !thumbOut) return GESTURE.POINT;

      // FAN: 4 ng√≥n (thumb ƒë√≥ng)
      if (!thumbOut && indexOut && middleOut && ringOut && pinkyOut) return GESTURE.FAN;

      // SPHERE: ng√≥n c√°i
      if (thumbOut && !indexOut && !middleOut && !ringOut && !pinkyOut) return GESTURE.SPHERE;

      // default: open palm => LOTUS
      return GESTURE.LOTUS;
    }

    // ======= NEW: ULT combo = ATTACK + WALL (2 tay) => emit SHAKA =======
    function isUltComboAttackWall(lmList){
      if (!lmList || lmList.length < 2) return false;
      const g0 = detectGestureSingle(lmList[0]);
      const g1 = detectGestureSingle(lmList[1]);
      return (g0 === GESTURE.ATTACK && g1 === GESTURE.WALL) ||
             (g0 === GESTURE.WALL && g1 === GESTURE.ATTACK);
    }

    // ======= AIM dir ∆∞u ti√™n tay POINT =======
    function computeAimDir(){
      let use = null;

      if (handRawL && detectGestureSingle(handRawL) === GESTURE.POINT) use = handRawL;
      if (handRawR && detectGestureSingle(handRawR) === GESTURE.POINT) use = handRawR;

      if (!use) use = primaryHandRaw || handRawR || handRawL;
      if (!use) return {x:0,y:0,z:0};

      const w = use[0];
      const i = use[8];
      const dx = (i.x - w.x);
      const dy = (i.y - w.y);
      const len = Math.sqrt(dx*dx + dy*dy) || 1;
      return { x: dx/len, y: -dy/len, z: -0.35 };
    }

    const STABLE_FRAMES = 4;
    const GESTURE_COOLDOWN_MS = 240;
    const gestureQueue = [];
    let lastCommittedGesture = GESTURE.IDLE;
    let lastGestureChangeAt = 0;

    let aimTimer = null;
    function startAimStream(){
      if (aimTimer) return;
      aimTimer = setInterval(()=>{
        if (!socket || !socket.connected || !joinedOk) return;
        if (!handDetected) return;
        socket.emit('aim', { dir: computeAimDir() });
      }, 100);
    }
    function stopAimStream(){
      if (!aimTimer) return;
      clearInterval(aimTimer);
      aimTimer = null;
    }

    function sendInput(gesture){
      if (!socket || !socket.connected || !joinedOk) return;
      const skillName = GESTURE_TO_SKILLNAME[gesture] || gesture;
      socket.emit('input', { gesture, skillName, dir: computeAimDir() });
    }

    function commitGesture(g){
      const now = Date.now();
      if (now - lastGestureChangeAt < GESTURE_COOLDOWN_MS) return;
      if (g === lastCommittedGesture && g !== GESTURE.POINT) return;

      lastCommittedGesture = g;
      lastGestureChangeAt = now;

      showSkillName(GESTURE_TO_SKILLNAME[g] || g);

      if (g === GESTURE.POINT) startAimStream();
      else stopAimStream();

      sendInput(g);
    }

    // ======= g√°n L/R theo multiHandedness =======
    function assignLR(results){
      handRawL = null;
      handRawR = null;
      primaryHandRaw = null;

      const lms = results.multiHandLandmarks || [];
      const handed = results.multiHandedness || [];
      if (lms.length === 0) return;

      primaryHandRaw = lms[0];

      for (let i = 0; i < lms.length; i++){
        const lm = lms[i];
        const label = handed[i]?.label;
        if (label === 'Left') handRawL = lm;
        else if (label === 'Right') handRawR = lm;
      }

      if (!handRawL && !handRawR && lms.length >= 2){
        const w0 = lms[0][0].x, w1 = lms[1][0].x;
        if (w0 < w1){ handRawR = lms[0]; handRawL = lms[1]; }
        else { handRawR = lms[1]; handRawL = lms[0]; }
      } else if (!handRawL && lms.length === 1){
        handRawR = lms[0];
      }
    }

    hands.onResults((results)=>{
      if (!gotFirstResults){
        gotFirstResults = true;
        loadingEl.style.display = 'none';
      }

      const lms = results.multiHandLandmarks || [];
      const handed = results.multiHandedness || [];

      if (lms.length > 0){
        handDetected = true;
        assignLR(results);

        // 1) GIANT hold ∆∞u ti√™n cao nh·∫•t
        const raised = isTwoHandsRaised(lms);
        if (handleGiantHold(raised)){
          gestureQueue.length = 0;
          return;
        }

        // 2) NEW: ULT combo (ATTACK + WALL) ∆∞u ti√™n tr∆∞·ªõc m·ªçi SHAKA 2-hand kh√°c
        if (isUltComboAttackWall(lms)){
          gestureQueue.length = 0;
          commitGesture(GESTURE.SHAKA); // ULT = SHAKA
          return;
        }

        // 3) 2-hand SHAKA c≈©
        const twoHand = detectTwoHandsGesture(lms, handed);

        // 4) single-hand
        const g = twoHand || detectGestureSingle(lms[0]);

        gestureQueue.push(g);
        if (gestureQueue.length > STABLE_FRAMES) gestureQueue.shift();

        if (gestureQueue.length === STABLE_FRAMES){
          const same = gestureQueue.every(x => x === gestureQueue[0]);
          if (same && gestureQueue[0]) commitGesture(gestureQueue[0]);
        }
      } else {
        handleGiantHold(false);
        handDetected = false;
        handRawL = null;
        handRawR = null;
        primaryHandRaw = null;
        gestureQueue.length = 0;
        stopAimStream();
      }
    });

    async function startCameraManually(){
      try{
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          throw new Error('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ getUserMedia');
        }

        loadingEl.style.display = 'block';
        loadingEl.innerHTML = 'ƒêang m·ªü camera...';

        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user", width: 640, height: 480 },
          audio: false
        });

        video.srcObject = stream;
        await video.play();

        loadingEl.innerHTML = 'ƒêang nh·∫≠n di·ªán b√†n tay...';

        let busy = false;
        async function frameLoop(){
          try{
            if (!busy && video.readyState >= 2){
              busy = true;
              await hands.send({ image: video });
              busy = false;
            }
          } catch(e){ busy = false; }
          requestAnimationFrame(frameLoop);
        }
        frameLoop();

      } catch(err){
        let msg = 'Kh√¥ng m·ªü ƒë∆∞·ª£c camera. ';
        if (err.name === 'NotAllowedError') msg += 'B·∫°n ƒë√£ ch·∫∑n quy·ªÅn camera.';
        else if (err.name === 'NotFoundError') msg += 'Kh√¥ng t√¨m th·∫•y camera.';
        else if (err.name === 'NotReadableError') msg += 'Camera ƒëang b·ªã app kh√°c d√πng.';
        else msg += `L·ªói: ${err.name || err.message || err}`;

        loadingEl.style.display = 'block';
        loadingEl.innerHTML =
          msg + '<br/>' +
          'M·∫πo: v√†o <b>Site settings ‚Üí Camera ‚Üí Allow</b>,<br/>' +
          'v√† m·ªü b·∫±ng <b>https</b> ho·∫∑c <b>http://localhost</b>.';
        startBtn.style.display = 'block';
      }
    }

    startBtn.addEventListener('click', ()=>{
      startBtn.style.display = 'none';
      startCameraManually();
    });

    // Keyboard quick test
    addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if (k === 'q') commitGesture(GESTURE.LOTUS);
      if (k === 'w') commitGesture(GESTURE.SPHERE);
      if (k === 'e') commitGesture(GESTURE.ATTACK);
      if (k === 'r') commitGesture(GESTURE.WALL);
      if (k === 't') commitGesture(GESTURE.SPIN);
      if (k === 'y') commitGesture(GESTURE.GIANT);
      if (k === 'u') commitGesture(GESTURE.FAN);
      if (k === 'i') commitGesture(GESTURE.SHAKA);
    });
  </script>
</body>
</html>
